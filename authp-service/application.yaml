server:
  port: 8082

spring:
  cloud:
    consul:
      discovery:
        prefer-ip-address: true # ğŸŒ å„ªå…ˆä½¿ç”¨ IP è¨»å†Šèˆ‡å¥åº·æª¢æŸ¥
        health-check-path: /actuator/health # â¤ï¸ å¥åº·æª¢æŸ¥ç«¯é»è·¯å¾‘
        ip-address: ${SERVICE_IP:${spring.cloud.client.ip-address}} # ğŸ§­ æœå‹™ IPï¼Œå„ªå…ˆç”¨ç’°å¢ƒè®Šæ•¸è¦†å¯«
        service-name: ${spring.application.name}  # ğŸ·ï¸ æœå‹™åç¨±ï¼ˆè¨»å†Šåˆ° Consulï¼‰
        instance-id: ${spring.application.name}-${server.port}  # ğŸ”¢ å¯¦ä¾‹ IDï¼Œé¿å…åŸ è™Ÿè¡çª

  cache:
    caffeine:
      spec: initialCapacity=100,maximumSize=500,expireAfterWrite=10m # Cache åˆå§‹å®¹é‡ã€æœ€å¤§å®¹é‡èˆ‡éæœŸæ™‚é–“é…ç½®

#  kafka:
#    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
#    consumer:
#      group-id: ${KAFKA_CONSUMER_GROUP_ID:authp-service}
#      auto-offset-reset: earliest
#      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
#      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
#    producer:
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      value-serializer: org.apache.kafka.common.serialization.StringSerializer

  # ä¾› MultiTenant provider å–é€£ç·šç”¨ï¼ˆBoot ä¸ç›´æ¥ç®¡ç† DataSourceï¼‰
  datasource:
    host: ${MYSQL_HOST:}
    port: ${MYSQL_PORT:}
    username: ${MYSQL_USERNAME:}
    password: ${MYSQL_PASSWORD:}

  jpa: # JPA å’Œ Hibernate é…ç½®
    properties:
      hibernate:
        show_sql: false # é¡¯ç¤º SQL èªå¥ï¼ˆé–‹ç™¼ç’°å¢ƒé–‹å•Ÿï¼‰
        format_sql: false # æ ¼å¼åŒ– SQL èªå¥ï¼ˆé–‹ç™¼ç’°å¢ƒé–‹å•Ÿï¼‰
    hibernate:
      ddl-auto: none # ç”Ÿç”¢ç’°å¢ƒå»ºè­°ä½¿ç”¨ none
    open-in-view: false # ç¦ç”¨ Open Session In Viewï¼Œä»¥æå‡æ€§èƒ½

authn:
  token:
    url: ${AUTHN_TOKEN_URL:http://api-gateway/authn/oauth2/token}  # ç™¼ token ç«¯

  client:
    id: ${AUTHN_CLIENT_ID:authp-service}                                 # åœ¨ AuthN è¨»å†Šçš„ client_id
    secret: ${AUTHP_CLIENT_SECRET:dummy}                                 # ç”¨ç’°å¢ƒè®Šæ•¸æˆ– Secret æ³¨å…¥
    auth-method: ${AUTHN_CLIENT_AUTH_METHOD:secret}                      # secret | private_key_jwtï¼ˆä½ ç”¨ secretï¼‰
    client-auth: ${AUTHN_CLIENT_AUTH_IN:header}                          # header(Basic) | body(form)
  audience: ${AUTHN_AUDIENCE:tenant-service}
  # â¬…ï¸ æ–°å¢ï¼šæŠŠå¯«å…¥ scope ä¸€èµ·çµ¦ï¼Œé¿å…æ‹¿ read-only token æ‰“ PUT è¢« 403
  scope: ${AUTHN_SCOPE:tenant.read tenant.bizform.read tenant.write}     # æœ€å°å¿…è¦æ¬Šé™

authp:
  http:
    timeout:
      connect-ms: 5000   # é€£ç·šå»ºç«‹é€¾æ™‚ï¼ˆæ¯«ç§’ï¼‰
      read-ms: 5000      # è®€å–å›æ‡‰é€¾æ™‚ï¼ˆæ¯«ç§’ï¼‰
#  kafka:
#    example-topic: ${AUTHP_KAFKA_EXAMPLE_TOPIC:authp-demo-topic}

external:
  http:
    timeout:
      connect-ms: 10000  # å°å¤–éƒ¨æœå‹™é€£ç·šé€¾æ™‚
      read-ms: 30000     # å°å¤–éƒ¨æœå‹™è®€å–é€¾æ™‚

# MultiTenant provider é€é Gateway å–å¾— DBInfo
gateway:
  target: tenant-read  # ç”³è«‹ M2M token çš„ target_serviceï¼ˆé¿å…ç°½ç™¼ç«¯ fallbackï¼‰
  base-url: http://api-gateway:8080  # Gateway åŸºåº•ä½å€

tenant:
  dbinfo-path: /tenant/api/tenants/%s  # DBInfo è·¯å¾‘ï¼Œä½¿ç”¨ tenantId æ ¼å¼åŒ–
  internal-base-url: http://tenant-service
  api-prefix: /directory

internal:
  token:
    expected-audience: authp-service           # TenantFilter ç”¨æ–¼åˆ¤æ–·ã€Œå…§éƒ¨ tokenã€

app:
  kafka:
    enabled: false  # åªåœ¨ä½ æœ‰ç”¨ @ConditionalOnProperty(name="app.kafka.enabled") æ™‚æœ‰ç”¨
  mt:
    jdbc:
      sslMode: REQUIRED                 # åœ¨ local dev æª”è¦†å¯«ç‚º DISABLED
      extra: ""
  security:
    public-paths:
      # ---------- ğŸ” å¥åº· / ç›£æ§ ----------
      - "/actuator/health"        # å¥åº·æª¢æŸ¥ (readiness / liveness)
      - "/actuator/prometheus"    # Prometheus æŒ‡æ¨™

      # ---------- ğŸ“„ Swagger / OpenAPI ----------
      - "/swagger-ui.html"        # Swagger UI
      - "/swagger-ui/**"          # Swagger éœæ…‹è³‡æº
      - "/v3/authp-docs"          # AuthP è‡ªè¨‚ docs å…¥å£

      - "/api/demo/kafka/**"